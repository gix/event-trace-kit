<#@ template debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
        dte = serviceProvider.GetService(typeof(SDTE)) as DTE;

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (dte == null)
        throw new Exception("T4 can only execute through the Visual Studio host");

    project = GetProjectContainingT4File(dte);
    if (project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return string.Empty;
    }

    appRoot = Path.GetDirectoryName(project.FullName) + '\\';
    rootNamespace = project.Properties.Item("RootNamespace").Value.ToString();
#>
using System.Threading;

<#
    try {
        allEntries = new List<ResourceEntry>();
        FindResourceFilesRecursivelyAndRecordEntries(project.ProjectItems, "");
        allEntries.Sort(
            (l, r) => {
                int cmp;
                if ((cmp = l.Path.CompareTo(r.Path)) != 0) return cmp;
                if ((cmp = l.File.CompareTo(r.File)) != 0) return cmp;
                if ((cmp = l.Name.CompareTo(r.Name)) != 0) return cmp;
                return cmp;
            });

        var currentNamespace = string.Empty;
        var currentClass = string.Empty;
        var thisIsFirstEntryInClass = true;
        var names = new List<string>();
        foreach (var entry in allEntries) {
            var newNamespace = entry.GetFullNamespace(rootNamespace);
            var newClass = entry.File;

            bool namespaceIsChanging = newNamespace != currentNamespace;
            bool classIsChanging = namespaceIsChanging || newClass != currentClass;

            // Close current class if class is changing.
            if (classIsChanging && !string.IsNullOrEmpty(currentClass)) {
                EmitNamesInnerClass(names);
                WriteLine("    }");
            }

            if (namespaceIsChanging) {
                // Close current namespace if opened.
                if (!string.IsNullOrEmpty(currentNamespace))
                    WriteLine("}");

                currentNamespace = newNamespace;

                // Open new namespace.
                WriteLine("namespace " + currentNamespace);
                WriteLine("{");
            }

            if (classIsChanging) {
                currentClass = newClass;
                WriteLine("    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(@\"" + Path.GetFileName(Host.TemplateFile) + "\", \"0\")]");
                WriteLine("    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");
                WriteLine("    internal static class " + currentClass);
                WriteLine("    {");
                thisIsFirstEntryInClass = true;

#>
        private static global::System.Resources.ResourceManager resourceMan;

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("<#= entry.GetFullName(rootNamespace) #>", typeof(<#=entry.File#>).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Returns the formatted resource string.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        private static string GetResourceString(string key, params string[] tokens)
        {
            var culture = Thread.CurrentThread.CurrentCulture;
            var str = ResourceManager.GetString(key, culture) ?? string.Empty;
            for (int i = 0; i + 1 < tokens.Length; i += 2)
                str = str.Replace(tokens[i], tokens[i + 1]);
            return str;
        }
<#
            }

            // Emit the static resource string access method for the current entry.
            if (entry.Comment != null) {
                if (!thisIsFirstEntryInClass)
                    WriteLine(string.Empty);
                WriteLine("");
                WriteLine("        /// <summary>");
                WriteLine("        ///   {0}", entry.Comment.Replace("\r\n", "\r\n        ///"));
                WriteLine("        /// </summary>");
            } else
                WriteLine(string.Empty);

            // Select all tokens between braces that constitute valid identifiers.
            var tokens = Regex.Matches(entry.Value, @"{(([A-Za-z]{1}\w*?)|([A-Za-z_]{1}\w+?))?}").Cast<Match>().Select(m => m.Value);
            if (tokens.Any()) {
                var inParams = tokens.Aggregate("", (list, value) => list += ", string " + value)
                    .Replace("{", "").Replace("}", "");
                if (inParams.Length > 0)
                    inParams = inParams.Substring(1);
                var outParams = tokens.Aggregate("", (list, value) => list += ", \"" + value +"\", " + value.Replace("{", "").Replace("}", "") );
                WriteLine("        public static string {0}({1})", entry.Name, inParams);
                WriteLine("        {");
                WriteLine("            return GetResourceString(\"{0}\"{1}); }}", entry.Name, outParams);
                WriteLine("        }");
            } else {
                WriteLine("        public static string " + entry.Name);
                WriteLine("        {");
                WriteLine("            get { return GetResourceString(\"" + entry.Name + "\"); }");
                WriteLine("        }");
            }

            names.Add(entry.Name);
            thisIsFirstEntryInClass = false;
        }

        // close out the current class when done
        if (!string.IsNullOrEmpty(currentClass)) {
            EmitNamesInnerClass(names);
            WriteLine("    }");
        }
    } catch (Exception ex) {
        Error(ex.ToString());
    }
#>
}
<#+
    private const string Kind_PhysicalFolder = "{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}";
    private const bool AlwaysKeepTemplateDirty = true;
    private static DTE dte;
    private static Project project;
    private static string appRoot;
    private static string rootNamespace;
    private static List<ResourceEntry> allEntries;

    void FindResourceFilesRecursivelyAndRecordEntries(ProjectItems items, string path)
    {
        foreach (ProjectItem item in items) {
            if (item.Kind == Kind_PhysicalFolder) {
                FindResourceFilesRecursivelyAndRecordEntries(item.ProjectItems, path + "." + item.Name);
                continue;
            }

            string customTool = (string)item.Properties.Item("CustomTool").Value;
            if (Path.GetExtension(item.Name) != ".resx" ||
                !string.IsNullOrEmpty(customTool))
                continue;

            RecordEntriesInResourceFile(item, path);
        }
    }

    void RecordEntriesInResourceFile(ProjectItem item, string path)
    {
        // Skip resource files except those for the default culture.
        if (Regex.IsMatch(item.Name, @".*\.[a-zA-z]{2}(-[a-zA-z]{2})?\.resx"))
            return;

        var file = Path.ChangeExtension(item.Name, null);
        var fileType = Path.GetExtension(item.Name);

        var filePath = (string)item.Properties.Item("FullPath").Value;
        var entries = XDocument.Load(filePath).Root.DescendantsAndSelf("data");

        foreach (XElement entryElement in entries) {
            var entry = new ResourceEntry {
                Path = path.Length > 0 ? path.Substring(1) : path,
                File = ConvertToValidIdentifier(file),
                Type = fileType,
                Name = ConvertToValidIdentifier(entryElement.Attribute("name").Value)
            };
            XElement value = entryElement.Element("value");
            if (value != null)
                entry.Value = value.Value;
            XElement comment = entryElement.Element("comment");
            if (comment != null)
                entry.Comment = comment.Value;

            allEntries.Add(entry);
        }
    }

    string ConvertToValidIdentifier(string arbitraryString)
    {
        string validIdentifier = Regex.Replace(arbitraryString, @"[^A-Za-z0-9-._]", " ");
        validIdentifier = ConvertToPascalCase(validIdentifier);
        if (Regex.IsMatch(validIdentifier, @"^\d"))
            validIdentifier = "_" + validIdentifier;
        return validIdentifier;
    }

    string ConvertToPascalCase(string phrase)
    {
        var builder = new StringBuilder();
        foreach (string part in phrase.Split(' ', '-', '.')) {
            if (part.Length == 0)
                continue;
            char[] chars = part.ToCharArray();
            chars[0] = char.ToUpper(chars[0]);
            builder.Append(new string(chars));
        }
        return builder.ToString();
    }

    void EmitNamesInnerClass(List<string> names)
    {
        if (names.Any()) {
            WriteLine("");
            WriteLine("        public static class Names");
            WriteLine("        {");
            foreach(var name in names)
                WriteLine("            public const string {0} = \"{0}\";", name);
            WriteLine("        }");

            names.Clear();
        }
    }

    Project GetProjectContainingT4File(DTE dte)
    {
        // Find the .tt file's ProjectItem
        ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

        // If the .tt file is not opened, open it.
        if (projectItem.Document == null)
            projectItem.Open(Constants.vsViewKindCode);

        if (AlwaysKeepTemplateDirty) {
            // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
            // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
            // Note: this is certainly hacky, but is the best I could come up with so far.
            projectItem.Document.Saved = false;
        }

        return projectItem.ContainingProject;
    }

    struct ResourceEntry
    {
        public string Path { get; set; }
        public string File { get; set; }
        public string Type { get; set; }
        public string Name { get; set; }
        public string Value { get; set; }
        public string Comment { get; set; }

        public string GetFullNamespace(string rootNamespace)
        {
            if (string.IsNullOrEmpty(Path))
                return rootNamespace;
            return rootNamespace + "." + Path;
        }

        public string GetFullName(string rootNamespace)
        {
            string ns = GetFullNamespace(rootNamespace);
            if (string.IsNullOrEmpty(ns))
                return File;
            return ns + "." + File;
        }
    }
#>
